# Trajectory

In this last chapter, we model the full trajectory of the Swainson's Warbler by combining the observation model of pressure with a movement model of flight accounting for likely speed to constrain possible distances between stationary periods. To do so, we use a highly optimized [Hidden Markov model](https://en.wikipedia.org/wiki/Hidden_Markov_model) presented in @Nussbaumer2023b.

This involves three mains steps:

1. *Create the graph* representing the possible trajectory of the bird
2. Define the *movement model* in terms of possible speed
3. *Compute three products* of the trajectory model: (1) the shortest path (i.e., the most likely trajectory), (2) the probability maps at each stationary period, and (3) simulated paths sampled according to their likelihood. 

If you haven't heard of Hidden Markov model, states-space models, or mathematical graphs, I recommend your start by reading the following section before moving to the code. To dive deeper into the use of state-space models to study animal movement, check out @Patterson2008.

<details>
<summary>Background on movement modeling</summary>

A fundamental consideration is to be able to separate the overall trajectory into discrete positions which, together, create a trajectory. Discrete animal movement is often modelled with a [Hidden Markov model](https://en.wikipedia.org/wiki/Hidden_Markov_model), which conveniently separates the unknown positions of a bird $X_t$ from some observations $Y_t$ which can be related to the position (e.g., pressure measurement). The key models required are:

- the *observation model* $P(Y_t | X_t)$, which provides the likelihood of observing the measurement assuming a known position. This is exactly what our likelihood map computed in the previous step does.
- the *movement model* $P(X_t+1|X_t)$ which defines the probability that the bird was flying between two stationary periods. 
- an *initial state* $P(X_0)$, technically required but this does not constitute a strong constraint in our case. 

Our goal is to produce a probability map for each stationary period which accounts for all pressure measurements, this is, computing the probability $P(X_t=x_t|Y_0=y_0,...Y_t=y_t)$. 

If you are not familiar with the lower and capital case, $X_t$ represents the random variable (i.e., the position of the bird at a stationary period t), while x_t are all the actually values that $X$ can take, that is, the coordinates of pixels on our map.

Because the number of possible positions is limited (to the number of pixels on the map), we can solve the HHM exactly. This is in contrast to Markov Chain Monte Carlo (MCMC) algorithm, which does not assume any discretization of the space but relies on an iterative approach to solve the model. 

A graph is a convenient mathematical representation of a model which has state (node) and some relations between these states (edge). Graphs are a general and fundamental mathematical tool, but here we use a specific graph structure corresponding to the HMM presented above: two states X and Y for each time step t (node), and an observation and movement model (relating X_t to X_t+1 and Y_t to X_t). All other relationships are assumed to be independent.

Typically in animal movement, the graph is only used to represent the HMM, but in our case, we use the graph to store all discrete positions (i.e., pixels) of all possible positions of the bird at all timesteps (called trellis graph). You can think of the edges as a full 3D grid of lat x lon x stationary period and the edges as all possible pairs of nodes between two consecutive stationary periods. As you can imagine, this results in a very high number of edges!

The novelty of @Nussbaumer2023b is to construct this graph using only the useful nodes and edges, to limit the computational cost. See below on how this is achieved. 

</details>


## Create the graph 

We create the trellis graph with the function `graph_create()`, which performs the following steps: 

1. Keep only the nodes of all locations within the `thr_likelihood`% percentile of the likelihood map.
2. Keep the nodes which are within reach of at least one node of the previous one, and of one node to the next stationary period, based on a average groundspeed `thr_gs` This is the key step which is efficiently computed with an image binary distance function [distmap()](https://rdrr.io/bioc/EBImage/man/distmap.html) from the [EBImage](https://github.com/aoles/EBImage) package, allowing to eliminate a high number of nodes without having to compute all the edges.
3. Build the edges based on the filtered nodes and the groundspeed threshold `thr_gs`.
4. Prune the graph based on the flow graph constraint, that is, the nodes must be connected to the equipment node(s) and retrieval node(s). Indeed, after filtering, some nodes might be connected in a single direction (so called dead branch). We thus ensure that each node is on a path that connects the equipment site to the retrieval site. This operation is performed with the [Breadth-first search (BFS) algorithm](https://en.wikipedia.org/wiki/Breadth-first_search).

These steps are explained and illustrated in more detail in section 2.2 of @Nussbaumer2023b.

```{r, warning = F, message=FALSE}
graph <- graph_create(tag,
  thr_likelihood = 0.90, # percentile 
  thr_gs = 100 # km/h
)
```

## Add movement model

We then define the movement model by setting a parametric function converting groundspeed to probability. 

In this basic tutorial, we use the gamma distribution to model the probability of groundspeed. Because birds may fly back and forth over small distances, we give all groundspeeds under 15km/h the same probability as for 15 km/h (`low_speed_fix`).

```{r}
graph <- graph_add_movement(graph, 
                            method = "gamma",
                            shape = 7,
                            scale = 7,
                            low_speed_fix = 15)
```

We can display the movement model with:

```{r}
plot_graph_movement(graph)
```

## Products
### Product 1: Most likely path

The graph can directly and efficiently compute the most likely path, that is, the set of positions for each stationary period which maximizes the joint probability of the trajectory. 

```{r, message=FALSE}
path_most_likely <- graph_most_likely(graph)
```

In GeoPressureR, we store the path as data.frame of the position (and other information taken from `graph$stap` for each stationary period). A path can be displayed on the map with `plot_path()`:

```{r}
plot_path(path_most_likely)
```


### Product 2: Marginal probability map

Estimating the uncertainty of the bird's position for each stationary period is generally the most sought-after output of tracking studies. While the pressure map provides some information for each stationary period, we can now produce the probability map of positions accounting for all observations and transitions. In the HMM, these maps correspond to the marginal distribution of a Markov process (see section 2.3.2 in @Nussbaumer2023b for more detail).

```{r, message=FALSE}
marginal <- graph_marginal(graph)
```


You can visualize the marginal map with plot_path. You can also add a layer with the most likely path:

```{r}
plot_map(marginal, path = path_most_likely)
```

### Product 3: Simulated paths

The most likely path does not represent the uncertainty of the modeled trajectory very well. In addition, if you want to perform any post hoc computation (e.g., mean flight distance), it is often more convenient to simulate multiple paths, compute the metric on each of them (e.g., flight distance) and compute the summary statistics afterwards (e.g., mean), instead of building this process within the HMM model which would require calculating the marginal of the pair-wise marginal distribution, typically very computationally expensive.

As the simulated trajectories are independent and sampled without error, you usually don't need many for any application.

```{r, message=FALSE}
path_simulation <- graph_simulation(graph, 
                                    nj = 10 # Number of simulation
                                    )
```

```{r}
plot_path(path_simulation)
```


## Save and export

Contrary to `tag` object, `graph` can be heavy if the number of stationary periods is high.

```{r}
# format(object.size(graph), units = "MB")
saveRDS(graph, file = "data/interim/graph-CB619.rds")
```

In addition to saving the graph object, you might want to export the three products. We recommend storing these in `data/processed` in a standard format which can be opened with other softwares. For paths (data.frame), a csv is the best option, while maps are best saved as geotiff using `terra::writeRaster`.

```{r, warning=F}
write.csv(path_most_likely, "data/processed/CB619/path_most_likely.csv", row.names = FALSE)
write.csv(path_simulation, "data/processed/CB619/path_simulation.csv", row.names = FALSE)
writeRaster(map2rast(marginal), "data/processed/CB619/marginal.tif", filetype = "GTiff", overwrite = TRUE)
```
