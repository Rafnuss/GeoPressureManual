# Trajectory

In this last chapter, we model the full trajectory of the Swainson's Warbler by combining the observation model of pressure with a movement model of flight accounting for likely speed to constrain possible distances between stationary periods. To do so, we use a highly optimized [Hidden Markov model](https://en.wikipedia.org/wiki/Hidden_Markov_model) presented in @Nussbaumer2023b.

This involves three mains steps:

1. *Create the graph* representing the possible trajectory of the bird
2. Define the *movement model* in terms of possible speed
3. *Compute three products* of the trajectory model: (1) the shortest path (i.e., the most likely trajectory), (2) the probability maps at each stationary period, and (3) simulated paths sampled according to their likelihood. 

If you haven't heard of Hidden Markov model, states-space models, or mathematical graphs, I recommend your start by reading the following section before moving to the code. To dive deeper into the use of state-space models to study animal movement, check out @Patterson2008.

<details>
<summary>Background on movement modelling</summary>

A fundamental consideration is to be able to separate the overall trajectory into discrete positions which, together, create a trajectory. Discrete animal movement is often modelled with a [Hidden Markov model](https://en.wikipedia.org/wiki/Hidden_Markov_model), which conveniently separates the unknown positions of a bird $X_t$ from some observations $Y_t$ which can be related to the position (e.g., pressure measurement). The key models required are:

- the *observation model* $P(Y_t | X_t)$, which provides the likelihood of observing the measurement assuming a known position. This is exactly what our likelihood map computed in the previous step does.
- the *movement model* $P(X_t+1|X_t)$ which defines the probability that the bird was flying between two stationary periods. 
- an *initial state* $P(X_0)$, technically required but this does not constitute a strong constraint in our case. 

Our goal is to produce a probability map for each stationary period which accounts for all pressure measurements, this is, computing the probability $P(X_t=x_t|Y_0=y_0,...Y_t=y_t)$. 

If you are not familiar with the lower and capital case, $X_t$ represents the random variable (i.e., the position of the bird at a stationary period t), while x_t are all the actually values that $X$ can take, that is, the coordinates of pixels on our map.

Because the number of possible positions is limited (to the number of pixels on the map), we can solve the HHM exactly. This is in contrast to Markov Chain Monte Carlo (MCMC) algorithm, which does not assume any discretization of the space but relies on an iterative approach to solve the model. 

A graph is a convenient mathematical representation of a model which has state (node) and some relations between these states (edge). Graphs are a general and fundamental mathematical tool, but here we use a specific graph structure corresponding to the HMM presented above: two states X and Y for each time step t (node), and an observation and movement model (relating X_t to X_t+1 and Y_t to X_t). All other relationships are assumed to be independent.

Typically in animal movement, the graph is only used to represent the HMM, but in our case, we use the graph to store all discrete positions (i.e., pixel) of all possible positions of the bird at all timesteps (called trellis graph). You can think of the edges as a full 3D grid of lat x lon x stationary period and the edges as all possible pairs of nodes between two consecutive stationary periods. As you can imagine, the number of edges is tremendous!

The novelty of @Nussbaumer2023b is to construct this graph with only the nodes and edges which are useful. See below on how this is achieved. 

</details>


## Create the graph 

We create the trellis graph with the function `graph_create()`, which performs the following steps: 

1. Keep only the nodes of all locations within the `thr_likelihood`% percentile of the likelihood map.
2. We only keep the nodes which are within reach of at least one nodes of the previous and one the next stationary period based on a average groundspeed `thr_gs` This is the key step which is efficiently computed with an image binary distance function [distmap()](https://rdrr.io/bioc/EBImage/man/distmap.html) from the [EBImage](https://github.com/aoles/EBImage) package, allowing to eliminate a great number of nodes without having to compute all the edges.
3. We then build the edges based on the filtered nodes and the threshold groundspeed `thr_gs`.
4. Finally, we prune the graph based on the flow graph constraint, that is, the nodes must be connected to the equipment node(s) and retrieval node(s). Indeed, after filtering, some nodes might be connected in a single direction (so called dead branch). We thus ensure that each node is on a path that connects the equipment site to the retrieval site. This operation is performed with the [Breadth-first search (BFS) algorithm](https://en.wikipedia.org/wiki/Breadth-first_search).

These steps are explained and illustrated with more details in section 2.2 of @Nussbaumer2023b.

```{r, warning = F, message=FALSE}
graph <- graph_create(tag,
  thr_likelihood = 0.90, # percentile 
  thr_gs = 100 # km/h
)
```

## Add movement model

We then define the movement model by setting a parametric function converting groundspeed to probability. 

In this basic tutorial, we use gamma distribution to model the probability of groundspeed. Because bird may flight back and forth over small distance, we give all groundspeed smaller than 15km/h the same probability than for 15 km/h (`low_speed_fix`).

```{r}
graph <- graph_add_movement(graph, 
                            method = "gamma",
                            shape = 7,
                            scale = 7,
                            low_speed_fix = 15)
```

We can disply the movement model

```{r}
plot_graph_movement(graph)
```

## Products
### Product 1: Most likely path

The graph can compute directly and efficiently the most likely path, that is, the set of positions for each stationary period which maximize the joint probability of the trajectory. 

```{r, message=FALSE}
path_most_likely <- graph_most_likely(graph)
```

In GeoPressureR, we store path as data.frame of the position (and other information taken from `graph$stap` for each stationary periods. A path can be displayed on the map with `plot_path()`

```{r}
plot_path(path_most_likely)
```


### Product 2: Marginal probability map

Estimating the uncertainty of the position of the bird for each stationary period is generally the most sought-after output of tracking studies. While the pressure map provided some information at each stationary periods, we can now produce the probability map of the position accounting for all observation and all transition. In HMM, these maps correspond to the marginal distribution of a Markov process (see section 2.3.2 in @Nussbaumer2023b for more details).

```{r, message=FALSE}
marginal <- graph_marginal(graph)
```


It might be interesting to plot the marginal map with the most likely path

```{r}
plot_map(marginal, path = path_most_likely)
```

### Product 3: Simulated paths

The most likely path does not represent well the uncertainty of the modeled trajectory. In addition, if you want to perform any post hoc computation (e.g., mean flight distance), it is often more convenient to simulated multiple paths, compute the metric on each of them (e.g. flight distance) and compute the summary statistic after (e.g. mean), instead of building this process within the HMM model which would require to compute the marginal of the pair-wise marginal distribution (typically very computational expensive). 

Because the simulated trajectory are independent and sampled without error, you usually don't need many for any application.  

```{r, message=FALSE}
path_simulation <- graph_simulation(graph, 
                                    nj = 10 # Number of simulation
                                    )
```

```{r}
plot_path(path_simulation)
```


## Save and export

While the `tag` object is generally not too big, `graph` can be really heavy if the number of stationary periods are numerous.

```{r}
# format(object.size(graph), units = "MB")
saveRDS(graph, file = "data/interim/graph-CB619.rds")
```

In addition or instead of to save the graph object, you might want to export the three outputs. The `data/processed` directory would be the right location for that, and using standard format which can be open with other software is a good solution. For paths (data.frame), a csv is be best option, while maps are best saved as geotiff using `terra::writeRaster`

```{r, warning=F}
write.csv(path_most_likely, "data/processed/CB619/path_most_likely.csv", row.names = FALSE)
write.csv(path_simulation, "data/processed/CB619/path_simulation.csv", row.names = FALSE)
writeRaster(map2rast(marginal), "data/processed/CB619/marginal.tif", filetype = "GTiff", overwrite = TRUE)
```
