[["index.html", "A User Manual for GeoPressureR Introduction 0.1 Geolocation by pressure 0.2 The GeoPressure suite 0.3 Installation", " A User Manual for GeoPressureR Introduction Understanding the temporal and spatial use of habitats by wildlife is crucial to apprehend ecological relationships in nature. Tracking small birds and bats requires tags of less than 2g, therefore lightweight geolocators are currently the most affordable and widespread option. Recent multi-sensor geolocators now capture accelerometer and pressure data in addition to light, offering new potential to refine the accuracy of bird positioning. In particular, as atmospheric pressure varies with space and time, pressure timeseries at a single location have a unique signature which can be used for global positioning independent of light recordings. 0.1 Geolocation by pressure The best introduction to geolocation by pressure is, in my opinion, to watch a video about it. Here is a 10min presentation which present the motivation, provides an overview of the method and illustrates some possible results. These two papers provide more detail on the method: Raphaël Nussbaumer, Mathieu Gravey, Martins Briedis, Felix Liechti. Global positioning with animal-borne pressure sensors, 14 June 2022, PREPRINT (Version 2) available at Research Square https://doi.org/10.21203/rs.3.rs-1381915/v2 Raphaël Nussbaumer, Mathieu Gravey, Martins Briedis, Felix Liechti. Inferring bird’s trajectory from multi-sensor geolocators and remote sensing with a graphical model, 25 May 2022, PREPRINT (Version 1) available at Research Square https://doi.org/10.21203/rs.3.rs-1693751/v1 0.2 The GeoPressure suite The GeoPressure suite includes several tools: GeoPressureR is the main R package which implements the full method and functionalities GeoPressureManual is the user guide developed to help you learn to use GeoPressureR GeoPressureTemplate is a template Github repository to help kickstart your project GeoPressureAPI is a JSON API that makes it easy to compute the mismatch of a geolocator pressure timeseries with the atmospheric pressure from ERA5 reanalysis data. This API is called directly by the functions geopressure_map() and geopressure_ts() in GeoPressureR, so you don’t have to worry about it. 0.3 Installation To start, install the GeoPressureR package from Github using the following line: install.packages(&quot;devtools&quot;) devtools::install_github(&quot;Rafnuss/GeoPressureR&quot;) We will be needing some additional packages which can be installed from DESCRIPTION with devtools::install() Finally, we can load them with library(GeoPressureR) # Only used for some visualization. The code to compute the light position is included in `GeoPressureR` library(GeoLocTools) setupGeolocation() # ERA5 data download library library(ecmwfr) # Graph library library(igraph) # Plotting library library(ggplot2) library(gridExtra) library(plotly) library(RColorBrewer) # Interactif figure library library(leaflet) library(leaflet.extras) "],["pressure-map.html", "Chapter 1 Pressure map 1.1 Read geolocator data 1.2 Label tracks 1.3 Identify stationary periods 1.4 Compute mistmatch maps 1.5 Compute probability maps 1.6 Compute altitude 1.7 Compute pressure and altitude for the path 1.8 Save", " Chapter 1 Pressure map This chapter covers the main steps to determine the position of a bird from pressure data. This code basically implement the method presented in Nussbaumer et al. (2022a). 1.1 Read geolocator data We read the geolocator data and crop it so that it starts on the equipment date and ends on the retrieval date. pam &lt;- pam_read( pathname = &quot;data/0_PAM/18LX&quot;, crop_start = &quot;2017-06-20&quot;, crop_end = &quot;2018-05-02&quot; ) pam_read() currently support data from Swiss Ornithological Institute files (*.pressure, *.lux, *.acceleration) and Migrate Technology (.deg, *.lux). For other file format, please contact me (submit a Github issue or email). 1.2 Label tracks To ensure the high level of precision needed for the pressure match, we must manually edit the activity classification and the pressure timeseries to be matched. We suggest doing this with TRAINSET. Labelling tracks is dedicated to this exercise and includes tips and best practices. Here, we will just walk through the main step of the workflow. 1.2.1 Automatic classification of activity We initialize the labeling file with an automatic classification of activity. We first use a k-mean clustering to group periods of low and high activity and then classify high activities lasting more than 30 minutes as migratory activities. See more possible classifications in the PALMr manual. pam &lt;- pam_classify(pam, min_duration = 30) If your track has only pressure data and no acceleration data, see this gitub issue. 1.2.2 Edit activity on TRAINSET Use trainset_write() to export the automatically generated classifications in a csv file, which can be opened in TRAINSET: https://trainset.geocene.com/. trainset_write(pam, pathname = &quot;data/1_pressure/labels/&quot;) # browseURL(&quot;https://trainset.geocene.com/&quot;) Printscreen of the manual classification in TRAINSET. See Labelling tracks for more information. When you have finished the manual editing, export the new csv file (TRAINSET will add -labeled in the name) in /data/1_pressure/labels/) and read this file with trainset_read(). pam &lt;- trainset_read(pam, pathname = &quot;data/1_pressure/labels/&quot;) 1.3 Identify stationary periods Based on the activity labeling, pam_sta() creates a table of stationary periods as illustrated below. pam &lt;- pam_sta(pam) knitr::kable(head(pam$sta)) sta_id start end 1 2017-06-20 00:00:00 2017-08-04 19:50:00 2 2017-08-04 23:15:00 2017-08-05 19:30:00 3 2017-08-06 02:50:00 2017-08-06 19:15:00 4 2017-08-07 03:10:00 2017-08-07 19:15:00 5 2017-08-08 00:10:00 2017-08-29 18:40:00 6 2017-08-30 04:30:00 2017-08-30 18:45:00 We can visualize the pressure measurements for each grouped stationary period (symbolized by a different color). The back dots represents the pressure labeled as outliar and these datapoint will not be matched. pressure_na &lt;- pam$pressure pressure_na$obs[pressure_na$isoutliar | pressure_na$sta_id == 0] &lt;- NA p &lt;- ggplot() + geom_line(data = pam$pressure, aes(x = date, y = obs), col = &quot;grey&quot;) + geom_line(data = pressure_na, aes(x = date, y = obs, col = as.factor(sta_id))) + geom_point(data = subset(pam$pressure, isoutliar), aes(x = date, y = obs), colour = &quot;black&quot;) + theme_bw() + scale_y_continuous(name = &quot;Pressure (hPa)&quot;) + scale_colour_manual(values = rep(RColorBrewer::brewer.pal(9, &quot;Set1&quot;), times = 8)) ggplotly(p, dynamicTicks = T) %&gt;% layout( showlegend = F, legend = list(orientation = &quot;h&quot;, x = -0.5), yaxis = list(title = &quot;Pressure [hPa]&quot;) ) 1.4 Compute mistmatch maps Now that we have clean pressure timeseries for each stationary period, we are ready to match each one with atmospheric pressure data (ERA5). To overcome the challenge of computing mismatch on such a large dataset, this R package uses the API GeoPressure to perform the computation on Google Earth Engine. Initially, it is easier and faster to query only long stationary periods (in the example below, we select only periods longer than 12hrs). You can do so by setting the pressure of the stationary periods you wish to discard to NA. sta_id_keep &lt;- pam$sta$sta_id[difftime(pam$sta$end, pam$sta$start, units = &quot;hours&quot;) &gt; 0] pam$pressure$sta_id[!(pam$pressure$sta_id %in% sta_id_keep)] &lt;- NA We can now query the data on the API with geopressure_map(). A detailed description of the parameters can be found here. This will take a couple of minutes to run. pressure_maps &lt;- geopressure_map( pam$pressure, extent = c(50, -16, 0, 23), # coordinates of the map to request (N, W, S, E) scale = 2, # request on a 1/2=0.5° grid to make the code faster max_sample = 250, # limit the query to the first 250 datapoints. margin = 30 # roughly equivalent to 3hPa ) geopressure_map() returns a list of two rasters for each stationary periods. The first is the mean square error (\\(\\textbf{MSE}\\)) between the pressure timeseries and ERA5 map. The second (\\(\\textbf{z}_{thr}\\)) is the proportion of datapoints in the pressure timeseries which correspond to an altitude that falls between the min and max altitude of each grid cell. Read more about these values and how they are computed here. 1.5 Compute probability maps We then combine the two rasters in a single probability map using \\[\\textbf{P} = \\exp \\left(-w \\frac{\\textbf{MSE}}{s} \\right) [\\textbf{z}_{thr}&gt;thr]\\] where \\(s\\) is the standard deviation of pressure and \\(thr\\) is the threshold mask. Because the auto-correlation of the timeseries is not accounted for in this equation, we use a log-linear pooling weight \\(w=\\log(n) - 1\\), where \\(n\\) is the number of datapoints in the timeseries. Probability aggregation describing the influence of log-linear pooling and length of timeseries will be added later. pressure_prob &lt;- geopressure_prob_map( pressure_maps, s = 1, # standard deviation of pressure thr = 0.9 # threshold of the threshold proportion value acceptable ) We use leaflet to visualize the threshold mask, mismatch map, and overall probability map for a single stationary period. i_r &lt;- 2 leaflet(width = &quot;100%&quot;) %&gt;% addProviderTiles(providers$Stamen.TerrainBackground) %&gt;% addFullscreenControl() %&gt;% addRasterImage(pressure_prob[[i_r]], opacity = 0.8, colors = &quot;OrRd&quot;, group = &quot;Probability&quot;) %&gt;% addRasterImage(pressure_maps[[i_r]][[1]], opacity = 0.8, colors = &quot;OrRd&quot;, group = &quot;Mismatch&quot;) %&gt;% addRasterImage(pressure_maps[[i_r]][[2]], opacity = 0.8, colors = &quot;OrRd&quot;, group = &quot;Threashold&quot;) %&gt;% # addLegend(pal = pal, values = values(v[[i_s]][[3]]), title = &quot;Probability&quot;) %&gt;% addLayersControl( overlayGroups = c(&quot;Probability&quot;, &quot;Mismatch&quot;, &quot;Threashold&quot;), options = layersControlOptions(collapsed = FALSE) ) %&gt;% hideGroup(c(&quot;Mismatch&quot;, &quot;Threashold&quot;)) We can also visualize the probability map for all stationary periods: li_s &lt;- list() l &lt;- leaflet(width = &quot;100%&quot;) %&gt;% addProviderTiles(providers$Stamen.TerrainBackground) %&gt;% addFullscreenControl() for (i_r in seq_len(length(pressure_prob))) { i_s &lt;- metadata(pressure_prob[[i_r]])$sta_id info &lt;- pam$sta[pam$sta$sta_id == i_s, ] info_str &lt;- paste0(i_s, &quot; | &quot;, format(info$start, &quot;%d-%b %H:%M&quot;), &quot;-&gt;&quot;, format(info$end, &quot;%d-%b %H:%M&quot;)) li_s &lt;- append(li_s, info_str) l &lt;- l %&gt;% addRasterImage(pressure_prob[[i_r]], opacity = 0.8, colors = &quot;OrRd&quot;, group = info_str) } l %&gt;% addLayersControl( overlayGroups = li_s, options = layersControlOptions(collapsed = FALSE) ) %&gt;% hideGroup(tail(li_s, length(li_s) - 1)) 1.6 Compute altitude The second operation you can perform with GeoPressureR is to compute the exact altitude of the bird \\(z_{gl}\\) from its pressure measurement \\(P_{gl}\\) using the barometric equation, correcting for the natural variation of pressure and temperature. This function used is \\[ z_{gl}(x)=z_{ERA5}(x) + \\frac{T_{ERA5}(x)}{L_b} \\left( \\frac{P_{gl}}{P_{ERA5}(x)} \\right) ^{\\frac{RL_b}{g M}-1},\\] where \\(z_{ERA}\\), \\(T_{ERA}\\) and \\(P_{ERA}\\) respectively correspond to the ground level elevation, temperature at 2m and ground level pressure of ERA5, \\(L_b\\) is the standard temperature lapse rate, \\(R\\) is the universal gas constant, \\(g\\) is the gravity constant and \\(M\\) is the molar mass of air. See more information here. To illustrate the benefit of using this equation, we will compute the bird’s altitude for its first stationary period using (1) GeoPressureR and (2) the barometric equation using standard atmosphere condition. We first determine the position of the bird by using the most likely postion using geopressure_map2path pt &lt;- geopressure_map2path(pressure_prob[1]) And then call the function geopressure_ts() with the subset of pressure containing sta_id==1 pressure_timeserie_1 &lt;- geopressure_ts(pt$lon, pt$lat, pressure = subset(pam$pressure, sta_id == 1)) We can compare the altitude produced to the one computed without the correction for temperature and pressure: Lb &lt;- -0.0065 R &lt;- 8.31432 g0 &lt;- 9.80665 M &lt;- 0.0289644 T0 &lt;- 273.15 + 15 P0 &lt;- 1013.25 pressure_timeserie_1$altitude_baro &lt;- T0 / Lb * ((pressure_timeserie_1$pressure / P0)^(-R * Lb / g0 / M) - 1) and visualize this comparison: p &lt;- ggplot() + geom_line(data = as.data.frame(pressure_timeserie_1), aes(x = date, y = altitude, col = as.factor(&quot;Corrected elevation with ERA5&quot;))) + geom_line(data = as.data.frame(pressure_timeserie_1), aes(x = date, y = altitude_baro, col = as.factor(&quot;Uncorrected elevation&quot;))) + labs(col = &quot;&quot;) + theme_bw() ggplotly(p) %&gt;% layout(legend = list(orientation = &quot;h&quot;, x = -0.5)) The function geopressure_ts() also returns the ground level pressure timeseries from ERA5 at the location specified. This is useful to check whether there is a good match between the pressure measured by the geolocator and the one at the assumed location. This operation is typically used to check the quality of the manual labelling (see Labelling tracks). 1.7 Compute pressure and altitude for the path We can repeat the computation of the pressure timeserie for all stationary periods. First we compute all the most likely position from the probability map of pressure. path &lt;- geopressure_map2path(pressure_prob) Secondly, we can use geopressure_ts_path() which basically call geopressure_ts() in parallel for all stationary periods. We can additionally request to compute the altitude during the next flight flight with include_flight = c(0,1). Note that if a position of the path is over water, it will be moved to the closest point onshore. pressure_timeserie &lt;- geopressure_ts_path(path, pam$pressure, include_flight = c(0, 1)) p &lt;- ggplot() + geom_line(data = do.call(&quot;rbind&quot;, pressure_timeserie), aes(x = date, y = altitude)) + theme_bw() + scale_y_continuous(name = &quot;Altitude (m)&quot;) ggplotly(p, dynamicTicks = T) %&gt;% layout(showlegend = F) col &lt;- rep(RColorBrewer::brewer.pal(9, &quot;Set1&quot;), times = ceiling((nrow(pam$sta) + 1) / 9)) col &lt;- col[1:(nrow(pam$sta) + 1)] names(col) &lt;- levels(factor(c(0, pam$sta$sta_id))) p &lt;- ggplot() + geom_line(data = pam$pressure, aes(x = date, y = obs), colour = &quot;grey&quot;) + geom_point(data = subset(pam$pressure, isoutliar), aes(x = date, y = obs), colour = &quot;black&quot;) + # geom_line(data = pressure_na, aes(x = date, y = obs, color = factor(sta_id))) + geom_line(data = subset(do.call(&quot;rbind&quot;, pressure_timeserie), sta_id != 0), aes(x = date, y = pressure0, col = factor(sta_id))) + theme_bw() + scale_colour_manual(values = col) + scale_y_continuous(name = &quot;Pressure (hPa)&quot;) ggplotly(p, dynamicTicks = T) %&gt;% layout(showlegend = F) 1.8 Save save( pressure_timeserie, pressure_prob, pam, file = &quot;data/1_pressure/18LX_pressure_prob.Rdata&quot; ) References "],["light-map.html", "Chapter 2 Light map 2.1 Annotate twilights 2.2 Calibrate zenith angles 2.3 Compute stationary periods 2.4 Compute probability map 2.5 Save", " Chapter 2 Light map In this vignette, we use light data to estimate the position of the Great Reed Warbler (18LCX) at each stationary period. A more thorough introduction to geolocation with light data can be found on https://geolocationmanual.vogelwarte.ch/ (Lisovski et al. 2020). We first load the data generated in Pressure map. load(&quot;data/1_pressure/18LX_pressure_prob.Rdata&quot;) For the calibration of light data, we need additional information. The second calibration is so short (1 day) with 18LX, so we discard it in this example. lon_calib &lt;- 17.05 lat_calib &lt;- 48.9 tm_calib_1 &lt;- c(pam$sta$start[1], pam$sta$end[1]) # tm_calib_2 &lt;- c(pam$sta$start[nrow(pam$sta)], pam$sta$end[nrow(pam$sta)]) 2.1 Annotate twilights To find the time of twilight, we can use find_twilights(), a function performing the same task than TwGeos::FindTwilight(), but differently. By default, the threshold is the first and last of light day (i.e., pam$light$obs&gt;0). The shift_k argument is identical to the offset in GeoLight functions. shift_k &lt;- 0 twl &lt;- find_twilights(pam$light, shift_k = shift_k ) We can visualize the twilight with TwGeos functions. raw_geolight &lt;- data.frame( Date = pam$light$date, Light = pam$light$obs ) lightImage( tagdata = raw_geolight, offset = shift_k / 60 / 60 ) tsimagePoints(twl$twilight, offset = 0, pch = 16, cex = 1.2) tsimageDeploymentLines(raw_geolight$Date, lon = lon_calib, lat = lat_calib, offset = shift_k / 60 / 60, lwd = 3, col = adjustcolor(&quot;orange&quot;, alpha.f = 0.5) ) abline(v = tm_calib_1, lty = c(1, 2), col = &quot;firebrick&quot;, lwd = 1.5) If you notice any issue with the centering of the night in this figure, specify manually shift_k. The manual editing is easily performed with TRAINSET. In this case, we must label the datapoints we want to delete. Read more about TRAINSET labelling in Labelling tracks. We write the twilight data on a csv file which can be opened and edited in TRAINSET. write.csv( data.frame( series = ifelse(twl$rise, &quot;Rise&quot;, &quot;Set&quot;), timestamp = strftime(twl$twilight, &quot;%Y-%m-%dT00:00:00Z&quot;, tz = &quot;UTC&quot;), value = (as.numeric(format(twl$twilight, &quot;%H&quot;)) * 60 + as.numeric(format(twl$twilight, &quot;%M&quot;)) - shift_k / 60 + 60 * 12) %% (60 * 24), label = ifelse(is.null(twl$delete), &quot;&quot;, ifelse(twl$delete, &quot;Delete&quot;, &quot;&quot;)) ), file = &quot;data/2_light/labels/18LX_light.csv&quot;, row.names = FALSE ) # browseURL(&quot;https://trainset.geocene.com/&quot;) When the labeling is finished, export the file and update the deleted field in twl. csv &lt;- read.csv(paste0(&quot;data/2_light/labels/18LX_light-labeled.csv&quot;)) twl$deleted &lt;- !csv$label == &quot;&quot; lightImage(tagdata = raw_geolight, offset = 0) tsimagePoints(twl$twilight, offset = 0, pch = 16, cex = 1.2, col = ifelse(twl$deleted, &quot;grey20&quot;, ifelse(twl$rise, &quot;firebrick&quot;, &quot;cornflowerblue&quot;)) ) abline(v = tm_calib_1, lty = c(1, 2), col = &quot;firebrick&quot;, lwd = 1.5) 2.2 Calibrate zenith angles Instead of calibrating the twilight errors in terms of duration, we directly model the zenith angle error. First, we retrieve the twilight during the calibration period. twl_calib &lt;- subset(twl, !deleted &amp; twilight &gt;= tm_calib_1[1] &amp; twilight &lt;= tm_calib_1[2]) We then compute the zenith angle (i.e., elevation of the sun) of the twilight time at the calibration site. sun &lt;- solar(twl_calib$twilight) z &lt;- refracted(zenith(sun, lon_calib, lat_calib)) Finally, we fit a kernel distribution for a relatively smooth bandwidth to account for possible bias. fit_z &lt;- density(z, adjust = 1.4, from = 60, to = 120) hist(z, freq = F) lines(fit_z, col = &quot;red&quot;) The adjust parameter allows to manually set how smooth you want the fit to be. Because the zenith angle error model is fitted with data only at the calibration site and that we are using it for all locations of the bird’s journey, it is safer to assume a broader/smoother distribution. 2.3 Compute stationary periods Before computing the probability map, we group the twilights by stationary period using activity classify in Pressure map | Identifying stationary periods. tmp &lt;- which(mapply(function(start, end) { start &lt; twl$twilight &amp; twl$twilight &lt; end }, pam$sta$start, pam$sta$end), arr.ind = TRUE) twl$sta_id &lt;- 0 twl$sta_id[tmp[, 1]] &lt;- tmp[, 2] 2.4 Compute probability map We first define a grid on which to compute the probabilities. For ease of comparison with the pressure-derived map, we load the grid size and resolution from pressure_prob (computed Pressure map | Computing mistmatch maps g &lt;- as.data.frame(pressure_prob[[1]], xy = TRUE) g$layer &lt;- NA Selecting only the unlabelled twilights, we compute the probability of observing the zenith angle of each twilight using the calibrated error function for each grid cell. twl_clean &lt;- subset(twl, !deleted) sun &lt;- solar(twl_clean$twilight) pgz &lt;- apply(g, 1, function(x) { z &lt;- refracted(zenith(sun, x[1], x[2])) approx(fit_z$x, fit_z$y, z, yleft = 0, yright = 0)$y }) Aggregating the probability map of each twilight per stationary period requires some assumptions on the independence/correlation of the twilight errors. Read more about this in Probability aggregation. Here, we use a log-linear pooling with a weight of \\(w=0.1\\), w &lt;- 0.1 We loop through each stationary period and create a raster map with the aggregated probabilities. light_prob &lt;- c() for (i_s in seq_len(nrow(pam$sta))) { id &lt;- twl_clean$sta_id == pam$sta$sta_id[i_s] if (sum(id) &gt; 1) { g$layer &lt;- exp(colSums(w * log(pgz[id, ]))) # Log-linear equation express in log } else if (sum(id) == 1) { g$layer &lt;- pgz[id, ] } else { g$layer &lt;- 1 } gr &lt;- rasterFromXYZ(g) crs(gr) &lt;- &quot;+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0&quot; metadata(gr) &lt;- list( sta_id = pam$sta$sta_id[i_s], nb_sample = sum(id) ) light_prob[[i_s]] &lt;- gr } Finally, we can visualize the probability map for each stationary period. See code for figure li_s &lt;- list() l &lt;- leaflet(width = &quot;100%&quot;) %&gt;% addProviderTiles(providers$Stamen.TerrainBackground) %&gt;% addFullscreenControl() for (i_r in seq_len(length(light_prob))) { i_s &lt;- metadata(light_prob[[i_r]])$sta_id info &lt;- pam$sta[pam$sta$sta_id == i_s, ] info_str &lt;- paste0(i_s, &quot; | &quot;, info$start, &quot;-&gt;&quot;, info$end) li_s &lt;- append(li_s, info_str) l &lt;- l %&gt;% addRasterImage(light_prob[[i_r]], opacity = 0.8, colors = &quot;OrRd&quot;, group = info_str) } m &lt;- l %&gt;% addCircles(lng = lon_calib, lat = lat_calib, color = &quot;black&quot;, opacity = 1) %&gt;% addLayersControl( overlayGroups = li_s, options = layersControlOptions(collapsed = FALSE) ) %&gt;% hideGroup(tail(li_s, length(li_s) - 1)) 2.5 Save save(twl, light_prob, z, fit_z, file = &quot;data/2_light/18LX_light_prob.Rdata&quot; ) References "],["static-map.html", "Chapter 3 Static map 3.1 Combine pressure and light 3.2 Check track with GeoPressureViz 3.3 Final checks 3.4 Save", " Chapter 3 Static map This chapter covers important pre-processing steps to ensure that modelling the trajectory with a graph is possible and successful. Firstly, we will aligned the maps of pressure and light and create a static_prob variable containing all the information necessary for modeling the trajectory (incl. flight info). But before moving too quickly, we need to carefully check that pressure, light and flight duration data allow for a coherent trajectory. It is possible (even probable) that some manual editing of the pressure data labeling will be required, especially for short stopovers. 3.1 Combine pressure and light Start by loading the data computed in Light map and Pressure map. load(&quot;data/1_pressure/18LX_pressure_prob.Rdata&quot;) load(&quot;data/2_light/18LX_light_prob.Rdata&quot;) We first need to retrieve the pressure and light data for the same stationary period. When running this code for the first time, it is recommended to start by keeping only long stationary periods (e.g. thr_sta_dur=5\\*24 hours), and when all the check below are passing, you can reduce this threshold to zero. thr_sta_dur &lt;- 0 # in hours sta_pres &lt;- unlist(lapply(pressure_prob, function(x) raster::metadata(x)$sta_id)) sta_light &lt;- unlist(lapply(light_prob, function(x) raster::metadata(x)$sta_id)) sta_thres &lt;- pam$sta$sta_id[difftime(pam$sta$end, pam$sta$start, units = &quot;hours&quot;) &gt; thr_sta_dur] # Get the sta_id present on all three data sources sta_id_keep &lt;- intersect(intersect(sta_pres, sta_light), sta_thres) # Filter pressure and light map pressure_prob &lt;- pressure_prob[sta_pres %in% sta_id_keep] light_prob &lt;- light_prob[sta_light %in% sta_id_keep] We then need to keep all the flights between consecutive stationary period separate so that we can estimate the wind support correctly. flight &lt;- list() for (i_f in seq_len(length(sta_id_keep) - 1)) { from_sta_id &lt;- sta_id_keep[i_f] to_sta_id &lt;- sta_id_keep[i_f + 1] flight[[i_f]] &lt;- list( start = pam$sta$end[seq(from_sta_id, to_sta_id - 1)], end = pam$sta$start[seq(from_sta_id + 1, to_sta_id)], sta_id = seq(from_sta_id, to_sta_id - 1) ) } flight[[i_f + 1]] &lt;- list() We compute the static probability with the product of light and pressure probability maps, and add the flight duration in the metadata. static_prob is the consolidate variable containing all the information necessary to run the graph functions. static_prob &lt;- mapply(function(light, pressure, flight) { # define static prob as the product of light and pressure prob static_prob &lt;- light * pressure # replace na by zero # tmp &lt;- values(static_prob) # tmp[is.na(tmp)] &lt;- 0 # values(static_prob) &lt;- tmp metadata(static_prob) &lt;- metadata(pressure) metadata(static_prob)$flight &lt;- flight return(static_prob) }, light_prob, pressure_prob, flight) We overwrite the probability of the first and last stationary periods with the known location of the equipment/retrieval sites. lon_calib &lt;- 17.05 lat_calib &lt;- 48.9 lat &lt;- seq(raster::ymax(static_prob[[1]]), raster::ymin(static_prob[[1]]), length.out = nrow(static_prob[[1]]) + 1) lat &lt;- lat[seq_len(length(lat) - 1)] + diff(lat[1:2]) / 2 lon &lt;- seq(raster::xmin(static_prob[[1]]), raster::xmax(static_prob[[1]]), length.out = ncol(static_prob[[1]]) + 1) lon &lt;- lon[seq_len(length(lon) - 1)] + diff(lon[1:2]) / 2 lon_calib_id &lt;- which.min(abs(lon_calib - lon)) lat_calib_id &lt;- which.min(abs(lat_calib - lat)) tmp &lt;- as.matrix(static_prob[[1]]) tmp[!is.na(tmp)] &lt;- 0 tmp[lat_calib_id, lon_calib_id] &lt;- 1 values(static_prob[[1]]) &lt;- tmp tmp &lt;- as.matrix(static_prob[[length(static_prob)]]) tmp[!is.na(tmp)] &lt;- 0 tmp[lat_calib_id, lon_calib_id] &lt;- 1 values(static_prob[[length(static_prob)]]) &lt;- tmp Finally, we can retrive the pressure and altitude from the most likely postion of the combined map of pressure and light. path &lt;- geopressure_map2path(static_prob) static_timeserie &lt;- geopressure_ts_path(path, pam$pressure) 3.2 Check track with GeoPressureViz Now that we have combine pressure and light, we need to verify that the data is coherent. This is a really important step, so bear with me here. In Labelling tracks, we had already checked that the pressure timeseries measured by the geolocator are consistent with a least one location on the map. But we didn’t checked that these position are (1) coherent with light data, and (2) within reach of one other considering the flight duration and realistic bird flight speed. To help you with this task, we have developed a shiny app GeoPressureViz which helps you visualize the overall trajectory of the bird as well as each step-by-step move. Screenshot of the GeoPressureViz demo showing the estimated position at one stationary period of the Great Reed Warbler 18LX, based on (1) the pressure and light match (map colorscale and timeserie) and (2) potential flight distances from previous and next stationary period (circles). 3.2.1 Navigate GeoPressureViz Open the demo for 18LX The viewer has three panels: The maps showing your the trajectory of the bird. The size of the circles indicates the duration of the stopover (hover over them to get more info). The bottom panel showing the pressure timeserie. The grey line is the raw day (pam$pressure), the black dots are pressure labeled as outliar, colored lines are the normalized pressure at the best match (i.e., static_timeserie$pressure0) and the color match the map dots. The side panel provides key information and helps you navigates the app A central parameter to play with carefully is the “Minimum duration”. This will filter the entire dataset and replot the map and figure to select only stopover of such duration or higher. Try changing this value once and wait a bit for the figure to update. As shorter stationary period are less certain, their position is often wrong. That’s ok for now. Toogle the “Full Track” button to move to the stationary period view. The side panel will change and provides you with more options. Change the stationary period with the drop down or previous/next button. Exept from the first sta., three dots, two lines and two circle will appears on the map, and the pressure timeserie will update to zoom exactly on this stationary period. The color of the timeserie informs you on which dots on the map is the current stationary period, the two others begin the previous and next one. The circles indicates the distance from and to the previous and last stationay period location based on the speed slider on the side pannel (default if 40km/h). You can edit the speed to see how this impact the distances. You can choose to display the probabily map of pressure (pressure_prob) , light (light_prob) or combines (static_prob). Because some location are completely off, it is helpful to change their location to check the coherence of distance with the next/previous stationary period. Use the button “Start Editing” to do that. Every time you will click on the map, it will update the position. Once you’re happy with the position, you can click again the button to disable the editing mode. Finally, you can update the pressure timeserie with the new position that you’ve edited with the button “Query pressure”. This runs pressure_ts on the background, so it will be slow (especially for long stationary period). This feature is quite unstable, so use carefully, and be aware that you might have to restart the app if it crashes. 3.2.2 Check your data With GeoPressureViz, we want to check that the probability map is coherent with the flight distance from the previous/next location. I suggest starting by selecting only long stopovers (24-72hours depending on your application), as this will help to draw out the general trajectory followed by the bird, and only later adding the shorter stopovers which could raise more confusion (the best match of pressure is often completely off). Following the same recommendation than in Labelling tracks, you want the non-outliar pressure of each stationary period to match a single elevation timeserie (bottom panel). You can check on the map that the pressure location seem coherent by selecting only “pressure” in the probability map display. Usually, it’s pretty obvious when there is an issue on the map. So, to correct any issue, go back to trainset and edit (1) labeling of activity to split or combine stationary periods and (2) labeling the pressure timeserie to exclude certain datapoints from the match. The good match of the timeserie is essential and will require several iteration. Some additional notes: - The distance is computed based on an assumed average groundspeed. Birds can fly with a groundspeed up to 120-150 km/h (with wind support) although their usual average is around 40km/h. - The default position of the bird in GeoPressureViz is based on the most likely position from the static probability map. This is (usually) not the correct location. - Bird tend to flight directly to their main destination. Most detour are artifact, or you really need a long stationary period with a good match of pressure. - The most regular issue I faced is a small vertical movement of the bird during a 2-8 days stopover. Shorter stopover are usually easy as the bird doesn’t move much but each species is different. 3.2.3 Run GeoPressureViz To run the visualization, you will need to save the data as ~/geopressureviz.RData (I cannot find a good way to pass variable to a shiny app instance, let me know if you have a suggestion). The minimum information needed is pam and static_prob, but to see the difference between light and pressure, you can also add light_prob and pressure_prob. To see the match of pressure timeserie in the bottom panel, add pressure_timeserie. geopressureviz &lt;- list( pam = pam, static_prob = static_prob, pressure_prob = pressure_prob, light_prob = light_prob, pressure_timeserie = static_timeserie ) save(geopressureviz, file = &quot;~/geopressureviz.RData&quot;) Run the app in the browser for best view with shiny::runApp(system.file(&quot;geopressureviz&quot;, package = &quot;GeoPressureR&quot;), launch.browser = getOption(&quot;browser&quot;)) 3.3 Final checks These checks are performed when creating the graph graph_create(), but for pedagogical reason, I thought it would be better to introduce them step by step here as they will also help you to get a better sense of the specific movement/trajectory of the bird you are modeling. 3.3.1 Check 1 A first and easy check is that there be at least one location with a probability greater than 1 for each stationary period. static_prob_n &lt;- lapply(static_prob, function(x) { probt &lt;- raster::as.matrix(x) probt[is.na(probt)] &lt;- 0 probt / sum(probt, na.rm = T) }) tmp &lt;- unlist(lapply(static_prob_n, sum)) == 0 if (any(tmp)) { warning(paste0( &quot;The `static_prob` provided has a probability map equal to &quot;, &quot;zero for the stationay period: &quot;, which(tmp) )) } 3.3.2 Check 2 Secondly, we check that there always be at least one possible transition from one stationary period to the next. for (i_s in seq_len(length(static_prob) - 1)) { cur &lt;- as.matrix(static_prob[[i_s]]) &gt; 0 cur[is.na(cur)] &lt;- F nex &lt;- as.matrix(static_prob[[i_s + 1]]) &gt; 0 nex[is.na(nex)] &lt;- F mtf &lt;- metadata(static_prob[[i_s]]) flight_duration &lt;- as.numeric(sum(difftime(mtf$flight$end, mtf$flight$start, unit = &quot;hours&quot;))) # hours resolution &lt;- mean(res(static_prob[[1]])) * 111 # assuming 1°= 111km thr_gs &lt;- 150 # Assuming a max groundspeed of 150km/h # Check possible position at next stationary period possible_next &lt;- (EBImage::distmap(!cur) * resolution / flight_duration) &lt; thr_gs if (sum(possible_next &amp; nex) == 0) { stop(paste(&quot;There are no possible transition from stationary period&quot;, i_s, &quot;to&quot;, i_s + 1, &quot;. Check part 1 process (light and pressure)&quot;, sep = &quot; &quot;)) } } 3.4 Save save(pam, static_prob, static_timeserie, file = &quot;data/3_static/18LX_static_prob.Rdata&quot; ) "],["basic-graph.html", "Chapter 4 Basic graph 4.1 Create the graph 4.2 Compute the transition probability 4.3 Output 1: Shortest path 4.4 Output 2: Marginal probability map 4.5 Output 3: Simulated paths 4.6 Save", " Chapter 4 Basic graph In this chapter, we will see how to create a mathematical graph to model the trajectory of the bird (Nussbaumer et al. 2022b). We will then use this graph to compute three main output: (1) the shortest path (i.e., the most likely trajectory, (2) the probability maps at each stationary period and (3) simulated paths sampled according to their likelihood. We called this a basic graph because it does not integrate windspeed, and make assumption on the groundspeed distribution of the bird. The chapte Wind graph will explain how we can retrieve wind data and improve the graph model. We already pre-processed the light and pressure data data in the chapter Static map. Make sure that the data was passing all the check before moving to this chapter load(&quot;data/3_static/18LX_static_prob.Rdata&quot;) To improve computational costs of creation of graph, it might be helpful to first run the model on a downscale resolution (fact &gt; 1) with the code below. We didn’t used this in our example. static_prob &lt;- lapply(static_prob, function(raster) { raster_ds &lt;- aggregate(raster, fact = 1, fun = max, na.rm = T, expand = T) # keep metadata metadata(raster_ds) &lt;- metadata(raster) return(raster_ds) }) 4.1 Create the graph We create the graph with the function graph_create(), which perform the following steps: We only keep the nodes of all locations within the 99% percentile of the static pressure map. (A node is uniquely identify by a latitude, longitude and stationary period). We only keep the nodes which are within reach of distance of all other nodes based on a average groundspeed of 150km/h. This accounts for the distance of all other possible nodes from the previous stationay period and to the next stationary period. This is computed with the image binary distance function distmap() from the EBImage package. This step allows to eliminate multiple impossible nodes without having to compute all possible transition. We then build the graph based on the filtered nodes and containing the edges requiring an average groundspeed less than 150km/h. Finally, we trim the graph based on the flow graph constraint, that is, the nodes must be connected to the equipment node and retrieval node. Indeed, after filtering, some nodes might be connected in a single direction (so called dead branch). We thus ensure that each node is on a path that connects the equipment site to the retrieval site. This operation is performed with the Breadth-first search (BFS) algorithm. The duration of this operation is strongly variable depending on the grid (resolution and size), the number of stationary periods and the level of contains from the static probability. grl &lt;- graph_create(static_prob, thr_prob_percentile = .99, thr_gs = 150 ) The graph returned is a list of the edges of the graph containing: s: source node (index in the 3d grid lat-lon-sta), t: target node (index in the 3d grid lat-lon-sta), gs:average ground speed required to make that transition (km/h) as complex number representing the E-W as real and S-N as imaginary. ps: static probability of each target node sz: size of the 3d grid lat-lon-sta equipement: node(s) of the first sta (index in the 3d grid lat-lon-sta) retrival: node(s) of the last sta (index in the 3d grid lat-lon-sta) flight_duration: list of flight duration to next sta in hours lat: list of the static_prob latitude in cell center lon: list of the static_prob longitude in cell center extent: raster geographical extent of the `static_prob`` resolution: raster res of the static_prob temporal_extent: start and end date time retrieved from the metadata of static_prob 4.2 Compute the transition probability We finally need to compute the probability of the transition represented by each edge of the graph. We use here a simple gamma distribution to model the probability of groundspeed. Because bird may flight back and forth over small distance, we give apparent groundspeed smaller than 20km/h the same probability than for 20 km/h. speed &lt;- seq(1, 120) low_speed_fix &lt;- 20 # minimum speed allowed prob &lt;- flight_prob(speed, method = &quot;gamma&quot;, shape = 7, scale = 7, low_speed_fix = low_speed_fix) plot(speed, prob, type = &quot;l&quot;, xlab = &quot;Groundspeed [km/h]&quot;, ylab = &quot;Probability&quot;) abline(v = low_speed_fix) grl$p &lt;- grl$ps * flight_prob(grl$gs, method = &quot;gamma&quot;, shape = 7, scale = 7, low_speed_fix = low_speed_fix) 4.3 Output 1: Shortest path In graph theory, the shortest path correspond to the set of nodes whose sum of the edges weights are as small as possible. By weighting the edges with the minus of the log of the probability, this corresponds to finding the most likely trajectory of our bird. We solve this problem with the igraph package g &lt;- graph_from_data_frame(data.frame( from = grl$s, to = grl$t, weight = -log(grl$p) )) # In case there are no retrival site, we select the position with the highest probability according to the marginal # retrival &lt;- which.max(as.matrix(static_prob_marginal[[length(static_prob_marginal)]])) + grl$sz[1] * grl$sz[2] * (grl$sz[3] - 1) sp &lt;- shortest_paths(g, from = paste(grl$equipement), to = paste(grl$retrival)) # Convert igraph representation to lat-lon shortest_path &lt;- graph_path2lonlat(as.numeric(sp$vpath[[1]]$name), grl) sta_duration &lt;- unlist(lapply(static_prob, function(x) { as.numeric(difftime(metadata(x)$temporal_extent[2], metadata(x)$temporal_extent[1], units = &quot;days&quot;)) })) leaflet(width = &quot;100%&quot;) %&gt;% addProviderTiles(providers$Stamen.TerrainBackground) %&gt;% addFullscreenControl() %&gt;% addPolylines(lng = shortest_path$lon, lat = shortest_path$lat, opacity = 1, color = &quot;#808080&quot;, weight = 3) %&gt;% addCircles(lng = shortest_path$lon, lat = shortest_path$lat, opacity = 1, color = &quot;#000&quot;, weight = sta_duration^(0.3) * 10) We retrieve the pressure and altitude for each stationary period at the most likely position. shortest_path_df &lt;- as.data.frame(shortest_path) shortest_path_timeserie &lt;- geopressure_ts_path(shortest_path_df, pam$pressure, include_flight = c(0, 1)) 4.4 Output 2: Marginal probability map Estimating the position of the bird for each stationary period is generally the most sought-after output of tracking studies. Using the graph built, we can compute this exactly (i.e., without iterative approach such as MCMC). This problem is the same as computing the marginal distribution of a Markov process which can be solved mathematically. static_prob_marginal &lt;- graph_marginal(grl) See code for figure li_s &lt;- list() l &lt;- leaflet(width = &quot;100%&quot;) %&gt;% addProviderTiles(providers$Stamen.TerrainBackground) %&gt;% addFullscreenControl() for (i_r in seq_len(length(static_prob_marginal))) { i_s &lt;- metadata(static_prob[[i_r]])$sta_id info &lt;- metadata(static_prob[[i_r]])$temporal_extent info_str &lt;- paste0(i_s, &quot; | &quot;, info[1], &quot;-&gt;&quot;, info[2]) li_s &lt;- append(li_s, info_str) l &lt;- l %&gt;% addRasterImage(static_prob_marginal[[i_r]], colors = &quot;OrRd&quot;, opacity = 0.8, group = info_str) %&gt;% addCircles(lng = shortest_path$lon[i_s], lat = shortest_path$lat[i_s], opacity = 1, color = &quot;#000&quot;, weight = 10, group = info_str) } m &lt;- l %&gt;% addLayersControl( overlayGroups = li_s, options = layersControlOptions(collapsed = FALSE) ) %&gt;% hideGroup(tail(li_s, length(li_s) - 1)) 4.5 Output 3: Simulated paths We can compute a few simulation paths. Because they are independent and without error, so you don’t need many, although the computation to request more is almost the same as a few. nj &lt;- 10 # Number of simulation path_sim &lt;- graph_simulation(grl, nj = nj) See code for figure col &lt;- rep(RColorBrewer::brewer.pal(9, &quot;Set1&quot;), times = ceiling(grl$sz[3] / 9)) m &lt;- leaflet(width = &quot;100%&quot;) %&gt;% addProviderTiles(providers$Stamen.TerrainBackground) %&gt;% addFullscreenControl() for (i in seq_len(nj)) { m &lt;- m %&gt;% addPolylines(lng = path_sim$lon[i, ], lat = path_sim$lat[i, ], opacity = 0.7, weight = 1, color = &quot;#808080&quot;) } for (i in seq_len(grl$sz[3])) { m &lt;- m %&gt;% addCircles(lng = path_sim$lon[, i], lat = path_sim$lat[, i], opacity = .4, weight = 10, color = col[i]) } # m &lt;- m %&gt;% addLegend(position=&quot;bottomright&quot;, colors = col[1:grl$sz[3]], labels = seq_len(grl$sz[3]), title = &quot;Stationay period&quot;, opacity = 1 ) 4.6 Save save( # grl, we are excluding grl because of its size on this repo. Feel free to keep it in your own project path_sim, shortest_path, static_prob_marginal, shortest_path_timeserie, file = &quot;data/4_basic_graph/18LX_basic_graph.Rdata&quot; ) References "]]
